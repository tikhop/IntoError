# How It Works

> Inspired by Rust's [thiserror](https://github.com/dtolnay/thiserror) crate.

## The Problem

Swift's error handling requires explicit conversion between error types. When building layered applications, you need to wrap lower-level errors into domain-specific types:

```swift
func fetchUser() throws(AppError) -> User {
    do {
        let data = try URLSession.shared.data(from: url)
        // ...
    } catch let error as URLError {
        throw AppError.network(error)
    } catch let error as DecodingError {
        throw AppError.parse(error)
    } catch {
        throw AppError.unknown(error)
    }
}
```

This boilerplate repeats throughout the codebase.

## Architecture

### `@IntoError` Macro

A combined **member + extension + peer macro** that attaches to an enum:

```swift
@IntoError
enum AppError {
    case network(URLError)
    case parse(DecodingError)
}
```

Generates:

```swift
enum AppError {
    case network(URLError)
    case parse(DecodingError)
    case unknown(any Error)  // auto-generated if no fallback case exists
}

// Extension with conformances and initializers
extension AppError: Error, ErrorConvertible {
    public init(from error: URLError) {
        self = .network(error)
    }

    public init(from error: DecodingError) {
        self = .parse(error)
    }

    public init(from error: any Error) {
        self = .unknown(error)
    }

    public init(converting error: any Error) {
        switch error {
        case let e as URLError: self = .network(e)
        case let e as DecodingError: self = .parse(e)
        default: self = .unknown(error)
        }
    }
}

// Postfix ^ operator for sync error conversion
postfix func ^<T>(
    _ expression: @autoclosure () throws -> T
) throws(AppError) -> T {
    do {
        return try expression()
    } catch let error as AppError {
        throw error
    } catch {
        throw AppError(converting: error)
    }
}
```

The macro:
1. Extracts each enum case's associated error type
2. Generates `case unknown(any Error)` if no fallback case exists
3. Generates typed `init(from:)` for each error type
4. Generates `init(converting:)` with type-matching switch
5. Generates a concrete postfix `^` operator (sync only)

### `@Err` Body Macro

The `^` operator uses `@autoclosure`, which doesn't work with async expressions. The `@Err` macro wraps the entire function body instead:

**With typed throws** — type inferred from signature:
```swift
@Err
func fetchData() async throws(AppError) -> Data {
    try await networkCall()
}
```

**With untyped throws** — type specified:
```swift
@Err(AppError.self)
func fetchData() async throws -> Data {
    try await networkCall()
}
```

Both expand to:
```swift
func fetchData() async throws(AppError) -> Data {
    do {
        return try await networkCall()
    } catch let error as AppError {
        throw error
    } catch {
        throw AppError(converting: error)
    }
}
```

### `ErrorConvertible` Protocol

```swift
public protocol ErrorConvertible: Error {
    init(converting error: any Error)
}
```

Used internally by the generated code for runtime error conversion.

### Why Concrete Operators

Swift doesn't infer generic parameters from the throws clause:

```swift
// Won't compile - E isn't inferred from throws(E)
func ^<T, E: ErrorConvertible>(expr: () throws -> T) throws(E) -> T
```

So `@IntoError` generates a concrete operator per enum type using `@attached(peer)`.

## Conversion Flow

### Sync (`^` operator)

```
try fetchData()^
       |
       v
+------------------+
| postfix func ^   |  (generated by @IntoError)
+------------------+
       |
       v
  do { try expr }
       |
       +-- success --> return value
       |
       +-- error
              |
              v
    +--------------------+
    | init(converting:)  |
    +--------------------+
              |
              v
         switch error {
           case URLError      -> .network
           case DecodingError -> .parse
           default            -> .unknown
         }
```

### Async (`@Err` macro)

```
@Err
func fetch() async throws(AppError) -> Data {
    try await networkCall()
}
       |
       v (compile-time expansion)
       |
func fetch() async throws(AppError) -> Data {
    do {
        return try await networkCall()
    } catch let error as AppError {
        throw error
    } catch {
        throw AppError(converting: error)
    }
}
```

## Limitations

1. **Sync `^` only** — Use `@Err` for async functions
2. **Single associated value** — Each case wraps one error type
3. **Fallback auto-generated** — `case unknown(any Error)` added if missing; declare your own to customize the name
